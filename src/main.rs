use std::{fs::File, io::Read};

use vm::emulator::Emulator;

use crate::vm::arch::{
    CmpFlags, InstructionDecodeIndices, InstructionOpcodes, Registers, Syscalls, VMConsts,
};

pub mod vm;

fn read_file_contents(file_path: &str) -> std::io::Result<Vec<u8>> {
    // Open the file in read-only mode
    let mut file = File::open(file_path)?;

    // Get the file metadata to determine its size
    let metadata = file.metadata()?;
    let file_size = metadata.len() as usize;

    // Create a Vec<u8> with the capacity of the file size
    let mut buffer = Vec::with_capacity(file_size);

    // Read the file contents into the buffer
    file.read_to_end(&mut buffer)?;

    Ok(buffer)
}

fn print_hex_dump(data: &[u8]) {
    // Define the number of bytes per line in the hexdump
    const BYTES_PER_LINE: usize = 16;

    for (i, chunk) in data.chunks(BYTES_PER_LINE).enumerate() {
        print!("{:08x}: ", i * BYTES_PER_LINE);

        // Print hexadecimal representation
        for byte in chunk {
            print!("{:02x} ", byte);
        }

        // Pad the last line in case the chunk size is smaller than BYTES_PER_LINE
        for _ in chunk.len()..BYTES_PER_LINE {
            print!("   ");
        }

        // Print the ASCII representation
        print!(" | ");
        for &byte in chunk {
            if byte.is_ascii_graphic() {
                print!("{}", byte as char);
            } else {
                print!(".");
            }
        }

        println!();
    }
}

fn main() {
    /*
    let emu_memory: Vec<u8> = vec![
        0x20, 0x04, 0x02, 0x04, 0x02, 0x04, 0x20, 0x40, 0xf1, 0x20, 0x10, 0x9f, 0x10, 0x10, 0x40,
        0x20, 0x40, 0xcd, 0x20, 0x10, 0xa0, 0x10, 0x10, 0x40, 0x20, 0x40, 0xec, 0x20, 0x10, 0xa1,
        0x10, 0x10, 0x40, 0x20, 0x40, 0x01, 0x20, 0x10, 0xa2, 0x10, 0x10, 0x40, 0x20, 0x40, 0x2d,
        0x20, 0x10, 0xa3, 0x10, 0x10, 0x40, 0x20, 0x40, 0x2c, 0x20, 0x10, 0xa4, 0x10, 0x10, 0x40,
        0x20, 0x40, 0x4f, 0x20, 0x10, 0xa5, 0x10, 0x10, 0x40, 0x20, 0x40, 0x2d, 0x20, 0x10, 0xa6,
        0x10, 0x10, 0x40, 0x20, 0x40, 0x92, 0x20, 0x10, 0xa7, 0x10, 0x10, 0x40, 0x20, 0x40, 0x43,
        0x20, 0x10, 0xa8, 0x10, 0x10, 0x40, 0x20, 0x40, 0xae, 0x20, 0x10, 0xa9, 0x10, 0x10, 0x40,
        0x20, 0x02, 0x74, 0x20, 0x04, 0x01, 0x80, 0x04, 0x01, 0x20, 0x40, 0x43, 0x04, 0x00, 0x40,
        0x20, 0x40, 0x4f, 0x04, 0x00, 0x40, 0x20, 0x40, 0x52, 0x04, 0x00, 0x40, 0x20, 0x40, 0x52,
        0x04, 0x00, 0x40, 0x20, 0x40, 0x45, 0x04, 0x00, 0x40, 0x20, 0x40, 0x43, 0x04, 0x00, 0x40,
        0x20, 0x40, 0x54, 0x04, 0x00, 0x40, 0x20, 0x40, 0x21, 0x04, 0x00, 0x40, 0x20, 0x40, 0x20,
        0x04, 0x00, 0x40, 0x20, 0x40, 0x59, 0x04, 0x00, 0x40, 0x20, 0x40, 0x6f, 0x04, 0x00, 0x40,
        0x20, 0x40, 0x75, 0x04, 0x00, 0x40, 0x20, 0x40, 0x72, 0x04, 0x00, 0x40, 0x20, 0x40, 0x20,
        0x04, 0x00, 0x40, 0x20, 0x40, 0x66, 0x04, 0x00, 0x40, 0x20, 0x40, 0x6c, 0x04, 0x00, 0x40,
        0x20, 0x40, 0x61, 0x04, 0x00, 0x40, 0x20, 0x40, 0x67, 0x04, 0x00, 0x40, 0x20, 0x40, 0x3a,
        0x04, 0x00, 0x40, 0x20, 0x40, 0x0a, 0x04, 0x00, 0x40, 0x20, 0x10, 0x14, 0x20, 0x20, 0x01,
        0x01, 0x08, 0x40, 0x20, 0x40, 0x2f, 0x20, 0x10, 0x80, 0x10, 0x10, 0x40, 0x20, 0x40, 0x66,
        0x20, 0x10, 0x81, 0x10, 0x10, 0x40, 0x20, 0x40, 0x6c, 0x20, 0x10, 0x82, 0x10, 0x10, 0x40,
        0x20, 0x40, 0x61, 0x20, 0x10, 0x83, 0x10, 0x10, 0x40, 0x20, 0x40, 0x67, 0x20, 0x10, 0x84,
        0x10, 0x10, 0x40, 0x20, 0x40, 0x00, 0x20, 0x10, 0x85, 0x10, 0x10, 0x40, 0x20, 0x20, 0x80,
        0x20, 0x04, 0x00, 0x01, 0x20, 0x40, 0x20, 0x04, 0x00, 0x80, 0x04, 0x01, 0x20, 0x10, 0xff,
        0x20, 0x20, 0x00, 0x80, 0x20, 0x40, 0x01, 0x10, 0x40, 0x20, 0x04, 0x00, 0x80, 0x04, 0x01,
        0x20, 0x10, 0x00, 0x80, 0x10, 0x40, 0x20, 0x20, 0x01, 0x01, 0x08, 0x40, 0x20, 0x20, 0x00,
        0x01, 0x04, 0x00, 0x04, 0x00, 0x20, 0x04, 0x00, 0x04, 0x04, 0x00, 0x10, 0x20, 0x04, 0x01,
        0x80, 0x04, 0x01, 0x20, 0x40, 0x4b, 0x04, 0x00, 0x40, 0x20, 0x40, 0x45, 0x04, 0x00, 0x40,
        0x20, 0x40, 0x59, 0x04, 0x00, 0x40, 0x20, 0x40, 0x3a, 0x04, 0x00, 0x40, 0x20, 0x40, 0x20,
        0x04, 0x00, 0x40, 0x20, 0x10, 0x05, 0x20, 0x20, 0x01, 0x01, 0x08, 0x40, 0x04, 0x10, 0x00,
        0x04, 0x04, 0x00, 0x04, 0x20, 0x00, 0x04, 0x00, 0x20, 0x04, 0x00, 0x04, 0x04, 0x00, 0x10,
        0x20, 0x04, 0x30, 0x20, 0x10, 0x0b, 0x20, 0x20, 0x00, 0x01, 0x10, 0x40, 0x04, 0x10, 0x00,
        0x04, 0x04, 0x00, 0x04, 0x20, 0x00, 0x20, 0x02, 0xc7, 0x20, 0x04, 0x01, 0x80, 0x04, 0x01,
        0x20, 0x40, 0x49, 0x04, 0x00, 0x40, 0x20, 0x40, 0x4e, 0x04, 0x00, 0x40, 0x20, 0x40, 0x43,
        0x04, 0x00, 0x40, 0x20, 0x40, 0x4f, 0x04, 0x00, 0x40, 0x20, 0x40, 0x52, 0x04, 0x00, 0x40,
        0x20, 0x40, 0x52, 0x04, 0x00, 0x40, 0x20, 0x40, 0x45, 0x04, 0x00, 0x40, 0x20, 0x40, 0x43,
        0x04, 0x00, 0x40, 0x20, 0x40, 0x54, 0x04, 0x00, 0x40, 0x20, 0x40, 0x21, 0x04, 0x00, 0x40,
        0x20, 0x40, 0x0a, 0x04, 0x00, 0x40, 0x20, 0x10, 0x0b, 0x20, 0x20, 0x01, 0x01, 0x08, 0x40,
        0x20, 0x20, 0x01, 0x01, 0x04, 0x00, 0x80, 0x20, 0x10, 0x80, 0x04, 0x10, 0x20, 0x40, 0xff,
        0x80, 0x20, 0x40, 0x80, 0x04, 0x40, 0x04, 0x00, 0x20, 0x04, 0x00, 0x04, 0x08, 0x20, 0x20,
        0x08, 0x04, 0x04, 0x02, 0x20, 0x04, 0x04, 0x04, 0x00, 0x04, 0x20, 0x00, 0x20, 0x40, 0xc5,
        0x40, 0x10, 0x40, 0x20, 0x40, 0xff, 0x80, 0x10, 0x40, 0x20, 0x40, 0x00, 0x02, 0x10, 0x40,
        0x20, 0x40, 0xb3, 0x40, 0x10, 0x40, 0x04, 0x40, 0x10, 0x04, 0x02, 0x00, 0x04, 0x00, 0x20,
        0x04, 0x00, 0x04, 0x04, 0x00, 0x10, 0x04, 0x10, 0x00, 0x04, 0x04, 0x00, 0x04, 0x20, 0x00,
        0x20, 0x02, 0xce, 0x20, 0x20, 0x30, 0x20, 0x04, 0xa1, 0x20, 0x10, 0x09, 0x20, 0x40, 0x02,
        0x80, 0x40, 0x02, 0x04, 0x00, 0x40, 0x20, 0x02, 0xb1, 0x20, 0x10, 0x00, 0x02, 0x40, 0x10,
        0x20, 0x40, 0x24, 0x40, 0x04, 0x40, 0x20, 0x40, 0x94, 0x40, 0x0a, 0x40,
    ];
    */
    let emu_memory = read_file_contents("121.bin").unwrap();

    print_hex_dump(&emu_memory);

    let mut raw_mem: Vec<u8> = vec![0; 0x407]; // 1024 bytes + 7 registers

    for (place, data) in raw_mem.iter_mut().zip(emu_memory.iter()) {
        *place = *data
    }

    let config_191 = VMConsts {
        opcodes: InstructionOpcodes {
            imm: 0x10,
            add: 0x1,
            stk: 0x4,
            stm: 0x2,
            ldm: 0x20,
            cmp: 0x40,
            jmp: 0x80,
            sys: 0x8,
        },
        syscalls: Syscalls {
            open: 0x20,
            read_memory: 0x8,
            write: 0x10,
        },
        instruction_indices: InstructionDecodeIndices {
            opcode: 1,
            left_param: 2,
            right_param: 0,
        },
        registers: Registers {
            a: 0x40,
            b: 0x10,
            c: 0x8,
            d: 0x1,
            s: 0x20,
            i: 0x4,
            f: 0x2,
            none: 0x0,
        },
        cmp_flags: CmpFlags {
            smaller: 0x2,
            bigger: 0x10,
            equals: 0x1,
            not_equals: 0x4,
            zero: 0x8,
        },
    };

    let config_200 = VMConsts {
        opcodes: InstructionOpcodes {
            imm: 0x40,
            add: 0x4,
            stk: 0x10,
            stm: 0x1,
            ldm: 0x20,
            cmp: 0x8,
            jmp: 0x2,
            sys: 0x80,
        },
        syscalls: Syscalls {
            open: 0x10,
            read_memory: 0x2,
            write: 0x20,
        },
        instruction_indices: InstructionDecodeIndices {
            opcode: 2,
            left_param: 1,
            right_param: 0,
        },
        registers: Registers {
            a: 0x20,
            b: 0x8,
            c: 0x2,
            d: 0x4,
            s: 0x40,
            i: 0x1,
            f: 0x10,
            none: 0x0,
        },
        cmp_flags: CmpFlags {
            smaller: 0x2,
            bigger: 0x8,
            equals: 0x10,
            not_equals: 0x1,
            zero: 0x4,
        },
    };

    let config_201 = VMConsts {
        opcodes: InstructionOpcodes {
            imm: 0x1,
            add: 0x10,
            stk: 0x2,
            stm: 0x8,
            ldm: 0x80,
            cmp: 0x40,
            jmp: 0x20,
            sys: 0x4,
        },
        syscalls: Syscalls {
            open: 0x8,
            read_memory: 0x1,
            write: 0x4,
        },
        instruction_indices: InstructionDecodeIndices {
            opcode: 0,
            left_param: 1,
            right_param: 2,
        },
        registers: Registers {
            a: 0x10,
            b: 0x8,
            c: 0x2,
            d: 0x40,
            s: 0x1,
            i: 0x4,
            f: 0x20,
            none: 0x0,
        },
        cmp_flags: CmpFlags {
            smaller: 0x2,
            bigger: 0x1,
            equals: 0x10,
            not_equals: 0x8,
            zero: 0x4,
        },
    };

    let mut emu = Emulator::new(raw_mem, config_201);

    println!("Starting emulator");

    loop {
        match emu.execute_next_instruction() {
            Err(err) => {
                println!("{}", err);
                break;
            }
            Ok(_) => {}
        }
    }
}
